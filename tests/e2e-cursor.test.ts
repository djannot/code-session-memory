/**
 * e2e-cursor.test.ts
 *
 * End-to-end tests for the Cursor pipeline:
 *   JSON fixture (cursor-session.json) → indexNewMessages
 *   → getSessionChunksOrdered → query
 *
 * - Embedder is mocked (no OpenAI calls)
 * - DB uses a real temp file
 * - Fixtures were generated by `npm run generate-fixtures` and committed
 */

import { describe, it, expect, vi } from "vitest";
import path from "path";
import fs from "fs";
import os from "os";

// ---------------------------------------------------------------------------
// Mock embedder before importing anything that touches it
// ---------------------------------------------------------------------------

const EMBEDDING_DIM = 3072;

vi.mock("../src/embedder", () => ({
  createEmbedder: () => ({
    embedText: vi.fn().mockResolvedValue(Array(EMBEDDING_DIM).fill(0.1)),
    embedBatch: vi.fn().mockImplementation(async (texts: string[]) =>
      texts.map(() => Array(EMBEDDING_DIM).fill(0.1)),
    ),
  }),
}));

// ---------------------------------------------------------------------------
// Imports (after mock setup)
// ---------------------------------------------------------------------------

import { indexNewMessagesWithOptions as indexNewMessages } from "../src/indexer";
import {
  openDatabase,
  getSessionMeta,
  getSessionChunksOrdered,
  listSessions,
  deleteSession,
} from "../src/database";
import type { SessionInfo, FullMessage } from "../src/types";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const FIXTURES = path.join(__dirname, "fixtures");
const MANIFEST = JSON.parse(fs.readFileSync(path.join(FIXTURES, "manifest.json"), "utf8")) as {
  cursor_composer_id: string;
};

interface CursorFixture {
  composerId: string;
  name: string;
  messages: FullMessage[];
}

function loadFixture(name: "cursor-session.json" | "cursor-turn1.json"): CursorFixture {
  return JSON.parse(fs.readFileSync(path.join(FIXTURES, name), "utf8")) as CursorFixture;
}

function makeTempDbPath(): string {
  const dir = path.join(
    os.tmpdir(),
    `opencode-e2e-cursor-${Date.now()}-${Math.random().toString(36).slice(2)}`,
  );
  fs.mkdirSync(dir, { recursive: true });
  return path.join(dir, "test.db");
}

const COMPOSER_ID = MANIFEST.cursor_composer_id;

function makeSession(fixture: CursorFixture): SessionInfo {
  return {
    id: fixture.composerId,
    title: fixture.name || "Cursor Test Session",
    directory: "/test/project",
  };
}

// ---------------------------------------------------------------------------
// Pipeline tests (with temp DB)
// ---------------------------------------------------------------------------

describe("indexNewMessages — Cursor", () => {
  it("indexes full session messages and stores chunks", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    const result = await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });
    expect(result.indexed).toBeGreaterThanOrEqual(1);
    expect(result.skipped).toBe(0);
  });

  it("sets last_indexed_message_id after indexing", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const meta = getSessionMeta(db, COMPOSER_ID);
    db.close();

    expect(meta).not.toBeNull();
    const lastMsg = full.messages[full.messages.length - 1];
    expect(meta!.last_indexed_message_id).toBe(lastMsg.info.id);
  });

  it("re-indexing the same session yields indexed:0", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");

    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });
    const second = await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    expect(second.indexed).toBe(0);
    expect(second.skipped).toBe(full.messages.length);
  });

  it("indexes only new messages when full session is run after turn1", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("cursor-turn1.json");
    const full = loadFixture("cursor-session.json");

    const first = await indexNewMessages(makeSession(turn1), turn1.messages, "cursor", { dbPath });
    const second = await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    expect(first.indexed).toBeGreaterThanOrEqual(1);
    // New messages = full - turn1 (may be 0 if they are the same)
    expect(second.indexed).toBe(full.messages.length - turn1.messages.length);
    expect(second.skipped).toBe(turn1.messages.length);
  });

  it("getSessionChunksOrdered returns chunks with ascending chunk_index", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, COMPOSER_ID);
    db.close();

    expect(chunks.length).toBeGreaterThan(0);
    for (let i = 1; i < chunks.length; i++) {
      expect(chunks[i].chunk_index).toBeGreaterThanOrEqual(chunks[i - 1].chunk_index);
    }
  });

  it("chunk content includes user message text", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, COMPOSER_ID);
    db.close();

    const allContent = chunks.map((c) => c.content).join("\n");
    // The user asked to "Use a tool to read a file"
    const userText = full.messages.find((m) => m.info.role === "user")?.parts.find(
      (p) => p.type === "text",
    )?.text ?? "";
    expect(allContent).toContain(userText.slice(0, 20));
  });

  it("session is stored with source=cursor", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const sessions = listSessions(db);
    db.close();

    expect(sessions.length).toBe(1);
    expect(sessions[0].source).toBe("cursor");
    expect(sessions[0].session_id).toBe(COMPOSER_ID);
  });

  it("deleteSession removes all chunks and meta", async () => {
    const dbPath = makeTempDbPath();
    const full = loadFixture("cursor-session.json");
    await indexNewMessages(makeSession(full), full.messages, "cursor", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunksBefore = getSessionChunksOrdered(db, COMPOSER_ID);
    expect(chunksBefore.length).toBeGreaterThan(0);

    deleteSession(db, COMPOSER_ID);

    const chunksAfter = getSessionChunksOrdered(db, COMPOSER_ID);
    const meta = getSessionMeta(db, COMPOSER_ID);
    const sessions = listSessions(db);
    db.close();

    expect(chunksAfter.length).toBe(0);
    expect(meta).toBeNull();
    expect(sessions.length).toBe(0);
  });
});
