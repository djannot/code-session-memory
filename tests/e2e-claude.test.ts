/**
 * e2e-claude.test.ts
 *
 * End-to-end tests for the Claude Code pipeline:
 *   JSONL fixture → parseTranscript → messageToMarkdown → chunkMarkdown
 *   → (mocked) embed → insertChunks → getSessionChunksOrdered
 *
 * - Embedder is mocked (no OpenAI calls)
 * - DB uses a real temp file (same pattern as indexer.test.ts)
 * - Fixtures were generated by `npm run generate-fixtures` and committed
 */

import { describe, it, expect, vi, beforeAll } from "vitest";
import path from "path";
import fs from "fs";
import os from "os";

// ---------------------------------------------------------------------------
// Mock embedder before importing anything that touches it
// ---------------------------------------------------------------------------

const EMBEDDING_DIM = 3072;

vi.mock("../src/embedder", () => ({
  createEmbedder: () => ({
    embedText: vi.fn().mockResolvedValue(Array(EMBEDDING_DIM).fill(0.1)),
    embedBatch: vi.fn().mockImplementation(async (texts: string[]) =>
      texts.map(() => Array(EMBEDDING_DIM).fill(0.1)),
    ),
  }),
}));

// ---------------------------------------------------------------------------
// Imports (after mock setup)
// ---------------------------------------------------------------------------

import { parseTranscript, deriveSessionTitle } from "../src/transcript-to-messages";
import { indexNewMessagesWithOptions as indexNewMessages } from "../src/indexer";
import { openDatabase, initSchema, getSessionMeta, getSessionChunksOrdered } from "../src/database";
import type { SessionInfo, FullMessage } from "../src/types";
import { mkdirSync } from "fs";
import { join } from "path";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const FIXTURES = path.join(__dirname, "fixtures");
const MANIFEST = JSON.parse(fs.readFileSync(path.join(FIXTURES, "manifest.json"), "utf8")) as {
  claude_session_id: string;
  opencode_session_id: string;
  generated_at: string;
};

function makeTempDbPath(): string {
  const dir = join(os.tmpdir(), `opencode-e2e-claude-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  mkdirSync(dir, { recursive: true });
  return join(dir, "test.db");
}

const TURN1_PATH = path.join(FIXTURES, "claude-turn1.jsonl");
const FULL_PATH  = path.join(FIXTURES, "claude-session.jsonl");
const SESSION_ID = MANIFEST.claude_session_id;

function makeSession(id = SESSION_ID): SessionInfo {
  return { id, title: "Claude E2E Test", directory: "/test/project" };
}

// ---------------------------------------------------------------------------
// Parse tests (no DB)
// ---------------------------------------------------------------------------

describe("parseTranscript — turn1", () => {
  let messages: FullMessage[];

  beforeAll(() => {
    messages = parseTranscript(TURN1_PATH);
  });

  it("produces at least one message", () => {
    expect(messages.length).toBeGreaterThanOrEqual(1);
  });

  it("has no duplicate message IDs", () => {
    const ids = messages.map((m) => m.info.id);
    const unique = new Set(ids);
    expect(unique.size).toBe(ids.length);
  });

  it("first message is a user message with the prompt text", () => {
    const firstUser = messages.find((m) => m.info.role === "user");
    expect(firstUser).toBeDefined();
    const textPart = firstUser!.parts.find((p) => p.type === "text");
    expect(textPart?.text).toMatch(/list files/i);
  });

  it("includes a tool_use (assistant calls Bash)", () => {
    const hasToolCall = messages.some((m) =>
      m.parts.some((p) => p.type === "tool-invocation" && p.state === "call"),
    );
    expect(hasToolCall).toBe(true);
  });

  it("includes a tool_result (user message with bash output)", () => {
    const hasToolResult = messages.some((m) =>
      m.parts.some((p) => p.type === "tool-invocation" && p.state === "result"),
    );
    expect(hasToolResult).toBe(true);
  });

  it("tool result content is non-empty (array content parsed correctly)", () => {
    const toolResultPart = messages
      .flatMap((m) => m.parts)
      .find((p) => p.type === "tool-invocation" && p.state === "result");
    expect(toolResultPart?.result).toBeTruthy();
    expect(toolResultPart?.result).not.toBe("(no output)");
  });

  it("deriveSessionTitle returns the prompt text", () => {
    const title = deriveSessionTitle(messages);
    expect(title.length).toBeGreaterThan(0);
    expect(title).toMatch(/list files/i);
  });

  it("tool_result messages have role='tool', not 'user'", () => {
    const toolResultMsg = messages.find((m) =>
      m.parts.some((p) => p.type === "tool-invocation" && p.state === "result"),
    );
    expect(toolResultMsg).toBeDefined();
    expect(toolResultMsg!.info.role).toBe("tool");
  });

  it("no tool_result message has role='user'", () => {
    const wrongRole = messages.find(
      (m) =>
        m.info.role === "user" &&
        m.parts.some((p) => p.type === "tool-invocation" && p.state === "result"),
    );
    expect(wrongRole).toBeUndefined();
  });
});

describe("parseTranscript — full session", () => {
  let turn1Messages: FullMessage[];
  let fullMessages: FullMessage[];

  beforeAll(() => {
    turn1Messages = parseTranscript(TURN1_PATH);
    fullMessages  = parseTranscript(FULL_PATH);
  });

  it("full session has more messages than turn1", () => {
    expect(fullMessages.length).toBeGreaterThan(turn1Messages.length);
  });

  it("no duplicates in full session", () => {
    const ids = fullMessages.map((m) => m.info.id);
    const unique = new Set(ids);
    expect(unique.size).toBe(ids.length);
  });

  it("turn1 message IDs are a prefix of full session IDs", () => {
    const turn1Ids = turn1Messages.map((m) => m.info.id);
    const fullIds  = fullMessages.map((m) => m.info.id);
    for (const id of turn1Ids) {
      expect(fullIds).toContain(id);
    }
  });
});

// ---------------------------------------------------------------------------
// Pipeline tests (with temp DB)
// ---------------------------------------------------------------------------

describe("indexNewMessages — Claude Code", () => {
  it("indexes turn1 messages and stores chunks", async () => {
    const dbPath = makeTempDbPath();
    const messages = parseTranscript(TURN1_PATH);
    const result = await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });
    expect(result.indexed).toBeGreaterThanOrEqual(1);
    expect(result.skipped).toBe(0);
  });

  it("sets last_indexed_message_id after turn1", async () => {
    const dbPath = makeTempDbPath();
    const messages = parseTranscript(TURN1_PATH);
    await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const meta = getSessionMeta(db, SESSION_ID);
    db.close();

    expect(meta).not.toBeNull();
    expect(meta!.last_indexed_message_id).toBe(messages[messages.length - 1].info.id);
  });

  it("re-indexing the same turn1 yields indexed:0", async () => {
    const dbPath = makeTempDbPath();
    const messages = parseTranscript(TURN1_PATH);

    await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });
    const second = await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });

    expect(second.indexed).toBe(0);
    expect(second.skipped).toBe(messages.length);
  });

  it("indexes only new messages when full session is run after turn1", async () => {
    const dbPath = makeTempDbPath();
    const turn1Messages = parseTranscript(TURN1_PATH);
    const fullMessages  = parseTranscript(FULL_PATH);

    const first  = await indexNewMessages(makeSession(), turn1Messages, "claude-code", { dbPath });
    const second = await indexNewMessages(makeSession(), fullMessages,  "claude-code", { dbPath });

    expect(first.indexed).toBeGreaterThanOrEqual(1);
    expect(second.indexed).toBe(fullMessages.length - turn1Messages.length);
    expect(second.skipped).toBe(turn1Messages.length);
  });

  it("getSessionChunksOrdered returns chunks with correct session_id", async () => {
    const dbPath = makeTempDbPath();
    const messages = parseTranscript(TURN1_PATH);
    await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, SESSION_ID);
    db.close();

    expect(chunks.length).toBeGreaterThan(0);
    // chunk_index should be increasing
    for (let i = 1; i < chunks.length; i++) {
      expect(chunks[i].chunk_index).toBeGreaterThanOrEqual(chunks[i - 1].chunk_index);
    }
  });

  it("chunk content includes the tool result text", async () => {
    const dbPath = makeTempDbPath();
    const messages = parseTranscript(TURN1_PATH);
    await indexNewMessages(makeSession(), messages, "claude-code", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, SESSION_ID);
    db.close();

    const allContent = chunks.map((c) => c.content).join("\n");
    // The bash output should contain file names from the ls -1 output
    expect(allContent).toMatch(/package\.json/);
  });
});
