/**
 * e2e-opencode.test.ts
 *
 * End-to-end tests for the OpenCode pipeline:
 *   JSON fixture (opencode export format) → messageToMarkdown / sessionToMarkdown
 *   → chunkMarkdown → (mocked) embed → insertChunks → getSessionChunksOrdered
 *
 * - Embedder is mocked (no OpenAI calls)
 * - DB uses a real temp file
 * - Fixtures were generated by `npm run generate-fixtures` and committed
 */

import { describe, it, expect, vi, beforeAll } from "vitest";
import path from "path";
import fs from "fs";
import os from "os";


// ---------------------------------------------------------------------------
// Mock embedder before importing anything that touches it
// ---------------------------------------------------------------------------

const EMBEDDING_DIM = 3072;

vi.mock("../src/embedder", () => ({
  createEmbedder: () => ({
    embedText: vi.fn().mockResolvedValue(Array(EMBEDDING_DIM).fill(0.1)),
    embedBatch: vi.fn().mockImplementation(async (texts: string[]) =>
      texts.map(() => Array(EMBEDDING_DIM).fill(0.1)),
    ),
  }),
}));

// ---------------------------------------------------------------------------
// Imports (after mock setup)
// ---------------------------------------------------------------------------

import { messageToMarkdown, sessionToMarkdown } from "../src/session-to-md";
import { indexNewMessagesWithOptions as indexNewMessages } from "../src/indexer";
import {
  openDatabase,
  getSessionMeta,
  getSessionChunksOrdered,
  listSessions,
  deleteSession,
} from "../src/database";
import type { SessionInfo, FullMessage } from "../src/types";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

const FIXTURES = path.join(__dirname, "fixtures");
const MANIFEST = JSON.parse(fs.readFileSync(path.join(FIXTURES, "manifest.json"), "utf8")) as {
  claude_session_id: string;
  opencode_session_id: string;
  generated_at: string;
};

function makeTempDbPath(): string {
  const dir = path.join(os.tmpdir(), `opencode-e2e-oc-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  fs.mkdirSync(dir, { recursive: true });
  return path.join(dir, "test.db");
}

interface ExportFixture {
  info: {
    id: string;
    title?: string;
    directory?: string;
  };
  messages: FullMessage[];
}

function loadFixture(name: "opencode-turn1.json" | "opencode-session.json"): ExportFixture {
  return JSON.parse(fs.readFileSync(path.join(FIXTURES, name), "utf8")) as ExportFixture;
}

const SESSION_ID = MANIFEST.opencode_session_id;

function makeSession(fixture: ExportFixture): SessionInfo {
  return {
    id: fixture.info.id,
    title: fixture.info.title,
    directory: fixture.info.directory,
  };
}

// ---------------------------------------------------------------------------
// messageToMarkdown tests (no DB)
// ---------------------------------------------------------------------------

describe("messageToMarkdown — OpenCode parts", () => {
  let turn1: ExportFixture;

  beforeAll(() => {
    turn1 = loadFixture("opencode-turn1.json");
  });

  it("renders user text message to non-empty markdown", () => {
    const userMsg = turn1.messages.find((m) => m.info.role === "user");
    expect(userMsg).toBeDefined();
    const md = messageToMarkdown(userMsg!);
    expect(md.trim().length).toBeGreaterThan(0);
    expect(md).toContain("## User");
  });

  it("renders assistant message with tool part to non-empty markdown", () => {
    const assistantMsg = turn1.messages.find((m) => m.info.role === "assistant");
    expect(assistantMsg).toBeDefined();
    const hasTool = assistantMsg!.parts.some((p) => p.type === "tool");
    expect(hasTool).toBe(true);

    const md = messageToMarkdown(assistantMsg!);
    expect(md.trim().length).toBeGreaterThan(0);
    expect(md).toContain("## Assistant");
  });

  it("tool part markdown includes tool name", () => {
    const assistantMsg = turn1.messages.find((m) =>
      m.parts.some((p) => p.type === "tool"),
    );
    const md = messageToMarkdown(assistantMsg!);
    // The glob tool was used — should show **Tool: glob**
    expect(md).toContain("**Tool:");
  });

  it("tool part markdown includes input and output", () => {
    const assistantMsg = turn1.messages.find((m) =>
      m.parts.some((p) => p.type === "tool"),
    );
    const md = messageToMarkdown(assistantMsg!);
    expect(md).toContain("**Input:**");
    expect(md).toContain("**Output:**");
  });
});

describe("sessionToMarkdown — full session", () => {
  it("produces non-empty markdown for the full session", () => {
    const full = loadFixture("opencode-session.json");
    const md = sessionToMarkdown(full.info, full.messages);
    expect(md.trim().length).toBeGreaterThan(0);
    expect(md).toContain("# ");
    expect(md).toContain("## User");
    expect(md).toContain("## Assistant");
  });
});

// ---------------------------------------------------------------------------
// Pipeline tests (with temp DB)
// ---------------------------------------------------------------------------

describe("indexNewMessages — OpenCode", () => {
  it("indexes turn1 messages and stores chunks", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    const result = await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });
    expect(result.indexed).toBeGreaterThanOrEqual(1);
    expect(result.skipped).toBe(0);
  });

  it("sets last_indexed_message_id after turn1", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const meta = getSessionMeta(db, SESSION_ID);
    db.close();

    expect(meta).not.toBeNull();
    const lastMsg = turn1.messages[turn1.messages.length - 1];
    expect(meta!.last_indexed_message_id).toBe(lastMsg.info.id);
  });

  it("re-indexing turn1 yields indexed:0", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");

    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });
    const second = await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    expect(second.indexed).toBe(0);
    expect(second.skipped).toBe(turn1.messages.length);
  });

  it("indexes only new messages when full session is run after turn1", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    const full  = loadFixture("opencode-session.json");

    const first  = await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });
    const second = await indexNewMessages(makeSession(full),  full.messages,  "opencode", { dbPath });

    expect(first.indexed).toBeGreaterThanOrEqual(1);
    expect(second.indexed).toBe(full.messages.length - turn1.messages.length);
    expect(second.skipped).toBe(turn1.messages.length);
  });

  it("getSessionChunksOrdered returns chunks with ascending chunk_index", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, SESSION_ID);
    db.close();

    expect(chunks.length).toBeGreaterThan(0);
    for (let i = 1; i < chunks.length; i++) {
      expect(chunks[i].chunk_index).toBeGreaterThanOrEqual(chunks[i - 1].chunk_index);
    }
  });

  it("chunk content includes tool output (glob results)", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, SESSION_ID);
    db.close();

    const allContent = chunks.map((c) => c.content).join("\n");
    // The glob tool returned .ts files — output should reference src/ or .ts
    expect(allContent).toMatch(/\.ts/);
  });

  it("listSessions returns the session with correct chunk count", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunks = getSessionChunksOrdered(db, SESSION_ID);
    const sessions = listSessions(db);
    db.close();

    expect(sessions.length).toBe(1);
    expect(sessions[0].session_id).toBe(SESSION_ID);
    expect(sessions[0].chunk_count).toBe(chunks.length);
    expect(sessions[0].source).toBe("opencode");
  });

  it("deleteSession removes all chunks and meta", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });

    const db = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunksBefore = getSessionChunksOrdered(db, SESSION_ID);
    expect(chunksBefore.length).toBeGreaterThan(0);

    deleteSession(db, SESSION_ID);

    const chunksAfter  = getSessionChunksOrdered(db, SESSION_ID);
    const meta         = getSessionMeta(db, SESSION_ID);
    const sessions     = listSessions(db);
    db.close();

    expect(chunksAfter.length).toBe(0);
    expect(meta).toBeNull();
    expect(sessions.length).toBe(0);
  });

  it("after delete + re-index, chunk count matches original", async () => {
    const dbPath = makeTempDbPath();
    const turn1 = loadFixture("opencode-turn1.json");

    // First index
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });
    const db1 = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunksBefore = getSessionChunksOrdered(db1, SESSION_ID).length;
    deleteSession(db1, SESSION_ID);
    db1.close();

    // Re-index
    await indexNewMessages(makeSession(turn1), turn1.messages, "opencode", { dbPath });
    const db2 = openDatabase({ dbPath, embeddingDimension: EMBEDDING_DIM });
    const chunksAfter = getSessionChunksOrdered(db2, SESSION_ID).length;
    db2.close();

    expect(chunksAfter).toBe(chunksBefore);
  });
});
